自定义注解+AOP

AOP是什么：就是在系统运行的的时候，动态的向系统添加代码的行为，就是面向切面编程
* 前置通知：在目标方法执行之前执行
* 后置通知：在目标方法执行之后执行
* 异常通知：当目标方法抛出异常的时候执行
* 返回通知：当目标方法有返回值的时候执行
* 环绕通知：这是一个集大成者，包含了上面的四种情况

在实际项目中，更多的是通过自定义注解+AOP解决各种项目问题
    1.事务处理
    2.接口限流处理:(基于Redis+Lua方法实现分布式限流)通过一个前置通知，在目标方法执行之前，统计目标方法在给定的时间窗内已经被调用了多少次了，如果超过了流量限制，就禁止执行。
    3.接口幂等性处理:项目中是在拦截器中实现的，但也可以使用AOP实现：通过一个前置通知，在目标方法执行之前，先去统计当前请求在给定的时间内是否以及执行过了，如果以及执行过来，就拒接本次执行。
    4.多数据源切换处理：通过一个前置通知，在目标方法执行之前，切换系统的数据源，这样，当目标方法执行的时候，就能够获得切换后的数据源数据了。
    5.日志记录处理：通过一个返回通知或者异常通知，当目标方法执行出错或者执行的时候有返回结果，通过一个异步任务，将日志记录下来。
    6.数据权限处理：通过一个前置通知，在目标方法执行之前，添加SQL条件，这些条件最终会被添加到Mapper层的SQL语句中，进而实现数据权限处理。
    7.XXXXTemplate... 这种模板基本底层都是AOP

AOP原理：
AOP就是基于动态代理，但是动态代理有两种实现方式：
    1.基于JDK的动态代理：要求被代理的对象即类要有接口
    2.基于CGLIB的动态代理：不需要被代理的对象有接口
  在spring中：
    1.如果被代理的对象有接口，那么默认使用JDK进行动态代理。
    2.如果被代理的对象没有接口，那么就使用CGLIB动态代理。
  在Spring Boot中：
    1.在Spring Boot2.0之前(不含2.0)
        a.如果开发者没有配置spring.aop.proxy-target-class属性，默认会使用JDK的动态代理。
        b.如果spring.aop.proxy-target-class属性为true，那么对于有接口的对象，也会使用CGLIB的动态代理。
        c.如果spring.aop.proxy-target-class属性为false，那么对于有接口的对象，会使用JDK的动态代。
    2.Spring Boot2.0之后
        a.默认情况下就是使用CGLIB的动态代理，无论被代理的对象是否有接口，都使用CGLIB的动态代理。
